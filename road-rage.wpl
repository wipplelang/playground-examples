use "game"

palette :: List Text
palette : list `rgb(255, 255, 255)` `rgb(0, 0, 0)` `rgb(189, 189, 189)` `rgb(253, 231, 2)` `rgb(81, 247, 22)` `rgb(35, 123, 0)` `rgb(251, 206, 165)` `rgb(249, 165, 3)` `rgb(148, 90, 41)` `rgb(58, 189, 255)` `rgb(123, 58, 255)` `rgb(6, 57, 247)` `rgb(246, 90, 185)` `rgb(245, 24, 5)` `rgb(57, 57, 57)` `rgb(239, 239, 239)`

from-palette :: Natural -> Text
from-palette : n -> palette . nth n . expect "invalid palette color"

ptc-audio :: Natural -> Text
ptc-audio : n -> format "https://github.com/WilsonGramer/games/raw/main/src/engine/backends/ptc/assets/audio/_.m4a" n

block :: Natural
block : 143

line :: Natural
line : 150

a-button :: Natural
a-button : 1

oncoming-car :: Natural
oncoming-car : 238

car :: Natural
car : 236

explosion :: Natural
explosion : 254

yellow-line-length :: Natural
yellow-line-length : 3

high-score :: Mutable Natural
high-score : mutable 0

background-room :: Maybe Natural -> Text -> Integer -> ()
background-room : score yellow-line-color yellow-line-offset -> {
  render-line ""
  render-line ""
  render-line ""
  fg (from-palette 13)
  render-line-fill "  XXX XXX XXX XX  " block
  render-line-fill "  X X X X X X X X " block
  render-line-fill "  XXX X X XXX X X " block
  render-line-fill "  XX  X X X X X X " block
  render-line-fill "  X X XXX X X XX  " block
  render-line-fill "                   " block
  render-line-fill "  XXX XXX XXX XXX X" block
  render-line-fill "  X X X X X   X   X" block
  render-line-fill "  XXX XXX X X XXX X" block
  render-line-fill "  XX  X X X X X    " block
  render-line-fill "  X X X X XXX XXX X" block
  render-line ""
  fg (from-palette 8)
  render-line "  (C) 2022"
  render-line "  Wilson Gramer"

  render-line (when score {
    Some score -> format "  Score: _" score
    None -> format "  High score: _" (get high-score)
  })

  fg (from-palette 15)
  (0 to height by 1) . each (y -> {
    locate (21 , y)
    render-glyph line
    locate (29 , y)
    render-glyph line
  })

  fg yellow-line-color
  (0 to (height + yellow-line-length) by 1) . each (y -> {
    if (((y as Integer - yellow-line-offset) mod (yellow-line-length as Integer)) > 0) {
      locate (25 , y - yellow-line-length)
      render-glyph line
    }
  })
}

title-room :: () -> () -> ()
title-room : () -> {
  () -> {
    background-room None (from-palette 8) -1

    play (Music {
      song : ptc-audio 1
      loop : True
    })

    fg (from-palette 14)
    locate (2 , 20)
    render-line "Press any button"
    locate (2 , 21)
    render-line "to start"

    if (button () is Some _) { room . set! (countdown-room ()) }
  }
}

countdown-room :: () -> () -> ()
countdown-room : () -> {
  clock : mutable (0 :: Natural)
  countdown : mutable (2 :: Natural)

  () -> {
    background-room None (from-palette 8) -1

    locate (22 , 9)
    render-line "Ready!!"

    if (get countdown <= 1) {
      locate (23 , 11)
      render-line "Set!!"
    }

    if (get countdown = 0) {
      locate (23 , 13)
      render-line "GO!!!"
    }

    increment! clock

    if (get clock mod 60 = 0) { if (get countdown = 0) { room . set! (game-room ()) } { countdown . set! (get countdown - 1) } }
  }
}

game-room :: () -> () -> ()
game-room : () -> {
  car-left-x :: Natural
  car-left-x : 22

  number-of-cars :: Natural
  number-of-cars : 7

  max-car-spawn-probability :: Number
  max-car-spawn-probability : 0.4

  car-spawn-probability-change :: Number
  car-spawn-probability-change : 0.0125

  min-car-spawn-probability :: Number
  min-car-spawn-probability : 0.3

  speed-interval :: Natural
  speed-interval : 35

  min-wait :: Natural
  min-wait : 3

  max-wait :: Natural
  max-wait : 7

  wait-change :: Natural
  wait-change : 1

  text-y :: Natural
  text-y : 10

  character-y :: Natural
  character-y : height - 4

  time : mutable 0
  wait-counter : mutable 0
  wait : mutable max-wait
  x : mutable 3
  yellow-line-offset : mutable 0
  car-spawn-probability : mutable max-car-spawn-probability
  cars : mutable Default
  hit-car : mutable False
  game-over-counter : mutable 0
  score : mutable 0

  () -> {
    background-room (Some (get score)) (if (get hit-car) (from-palette 8) (from-palette 7)) (get yellow-line-offset)

    if (get hit-car) {
      play (Music {
        song : ptc-audio 6
        loop : False
      })
    } {
      play (Music {
        song : ptc-audio 2
        loop : True
      })
    }

    get cars . each ((x , y) -> {
      locate (car-left-x + x , y)
      fg (if (y > character-y or get hit-car) (from-palette 14) (from-palette 15))
      render-glyph oncoming-car
    })

    if (get hit-car) {
      fg (from-palette 15)
      locate (car-left-x + 1 , text-y)
      render-line "GAME"
      locate (car-left-x + 1 , text-y + 2)
      render-line "OVER!"
    }

    locate (car-left-x + get x , character-y)
    fg (from-palette 13)

    render-glyph (if (get hit-car) explosion car)

    if (get game-over-counter >= 120) {
      if (button () is Some _) {
        room . set! (title-room ())
      }

      end ()
    }

    if (get cars . reduce False ((x , y) hit -> hit or (x = get x and y = character-y))) {
      hit-car . set! True

      if (get score > get high-score) {
        high-score . set! (get score)
      }
    }

    if (get hit-car) {
      increment! game-over-counter

      end ()
    }

    increment! time

    if (get time mod (get wait) /= 0) {
      end ()
    }

    increment! wait-counter

    new-x : when (button ()) {
      Some Left -> (max (get x as Integer - 1) 0) as! Natural
      Some Right -> min (get x + 1) (number-of-cars - 1)
      _ -> get x
    }

    updated-cars : mutable (get cars . try-filter ((x , y) -> {
      if (y < height) (Some (x , (y + 1))) None
    }) . collect :: List _)

    if (random (0.000 to 1.000) < get car-spawn-probability) {
      updated-cars . append! (random (0 to number-of-cars) , 0)
    }

    reached-wait : (get wait-counter mod speed-interval) = 0

    x . set! new-x

    yellow-line-offset . set! ((get yellow-line-offset + 1) mod yellow-line-length as Integer)

    if reached-wait {
      wait . set! (max (get wait - wait-change) min-wait)
      car-spawn-probability . set! (max (get car-spawn-probability - car-spawn-probability-change) min-car-spawn-probability)
    }

    cars . set! (get updated-cars)

    score . add! (get updated-cars . filter ((_ , y) -> y = character-y + 1) . count)
  }
}

room :: Mutable (() -> ())
room : mutable (title-room ())

with-game { get room () }
